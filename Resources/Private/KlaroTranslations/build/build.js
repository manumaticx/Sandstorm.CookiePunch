var fs = require("fs");
var path = require("path");
const Handlebars = require("handlebars");
const yaml = require("js-yaml");

const templateDir = __dirname;
const klaroTranslationsDir = path.join(__dirname, "../");
const fusionTranslationFile = path.join(
  __dirname,
  "../../Fusion",
  "Config.Translations.fusion"
);
const settingsYamlTranslationFile = path.join(
  __dirname,
  "../../../../Configuration",
  "Settings.Translations.yaml"
);
const xlfTranslationsDir = path.join(__dirname, "../../Translations");
const xlfName = "Klaro";
``;
const autoGeneratedNotice = `
################################################################################################
# IMPORTANT: This file was auto-generated as part of the build process to convert translations #
# provided by klaro. -> see package.json -> "yarn run build:translations"                      #
################################################################################################

`;

const fusionTemplate = Handlebars.compile(
  fs.readFileSync(path.join(templateDir, "fusionTemplate.hbs"), {
    encoding: "utf-8",
  })
);

const xlfTemplate = Handlebars.compile(
  fs.readFileSync(path.join(templateDir, "xlfTemplate.hbs"), {
    encoding: "utf-8",
  })
);

const enJson = yaml.safeLoad(
  fs.readFileSync(path.join(klaroTranslationsDir, "en.yml"), {
    encoding: "utf-8",
  })
);
const enFlattened = flattenJson(enJson);

fs.readdir(klaroTranslationsDir, function (err, files) {
  files
    .filter((file) => file.indexOf(".yml") >= 0)
    .forEach((file) => {
      const language = file.replace(".yml", "");
      const json = yaml.safeLoad(
        fs.readFileSync(path.join(klaroTranslationsDir, file), "utf8")
      );
      const flattened = flattenJson(json);
      const xlfUnits = buildXlfUnits(flattened, language);

      if (language === "en") {
        const fusion = fusionTemplate({
          units: xlfUnits,
        });
        fs.writeFileSync(fusionTranslationFile, fusion, {
          encoding: "utf8",
          flag: "w",
        });

        const settingsYaml = yaml.safeDump({
          Sandstorm: {
            CookiePunch: {
              translations: jsonToYamlWithPath(
                json,
                `Sandstorm.CookiePunch:${xlfName}:`
              ),
            },
          },
        });
        fs.writeFileSync(
          settingsYamlTranslationFile,
          autoGeneratedNotice + settingsYaml,
          { encoding: "utf8", flag: "w" }
        );
      }

      const xlf = xlfTemplate({
        units: xlfUnits,
        source: "en",
        target: language !== "en" ? language : undefined,
      });
      const dir = path.join(xlfTranslationsDir, language);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir);
      }
      fs.writeFileSync(path.join(dir, `${xlfName}.xlf`), xlf, {
        encoding: "utf8",
        flag: "w",
      });
    });
});

function buildXlfUnits(flattened, language) {
  return Object.keys(flattened).map((key) => {
    if (language !== "en") {
      return {
        id: key,
        target: flattened[key],
        source: enFlattened[key],
        language: language,
      };
    } else {
      return {
        id: key,
        source: flattened[key],
        language: language,
      };
    }
  });
}

function flattenJson(data) {
  var result = {};
  function recurse(cur, prop) {
    if (Object(cur) !== cur) {
      result[prop] = cur;
    } else if (Array.isArray(cur)) {
      for (var i = 0, l = cur.length; i < l; i++)
        recurse(cur[i], prop ? prop + "." + i : "" + i);
      if (l == 0) result[prop] = [];
    } else {
      var isEmpty = true;
      for (var p in cur) {
        isEmpty = false;
        recurse(cur[p], prop ? prop + "." + p : p);
      }
      if (isEmpty) result[prop] = {};
    }
  }
  recurse(data, "");
  return result;
}

function jsonToYamlWithPath(data, path = "") {
  let clonedData = JSON.parse(JSON.stringify(data));
  function recurse(current, path) {
    if (typeof current === "object") {
      for (let property in current) {
        if (current.hasOwnProperty(property)) {
          if (typeof current[property] === "object") {
            recurse(current[property], path + property + ".");
          } else {
            current[property] = path + property;
          }
        }
      }
    }
  }

  recurse(clonedData, path);

  return clonedData;
}
